(function() {if (typeof talon === "undefined") {talon = {files: {}, funcs: {print: 1, printf: 1, printc: 1, getstr: 1, format: 1, colored: 1, import: 1, int: 1, float: 1, round: 1, log: 1, sqrt: 1, sin: 1, cos: 1, tan: 1, asin: 1, acos: 1, atan: 1, atan2: 1, random: 1, randomint: 1, str: 1, len: 1, ord: 1, chr: 1, lower: 1, upper: 1, startswith: 1, endswith: 1, replace: 1, split: 1, list: 1, append: 1, pop: 1, push: 1, remove: 1, reverse: 1, sort: 1}, vars: {}}}; let groupEnv = talon; groupEnv.files["atjs.tal"] = {run(env = groupEnv) {setNew(env, "atjs_builtins", [["print", "(...args) {console.log(...convertStyles(args.map(d => f_str(d)).join(\" \")))}"], ["printf", "(string, list) {f_print(f_format(string, list))}"], ["printc", "(string) {f_print(f_colored(string))}"], ["getstr", "(message) {return prompt(message === undefined ? undefined : f_str(message))}"], ["format", "(string, list) {return string.replace(/%(%|-?\\d+)/, (m, code) => code == \"%\" ? \"%\" : f_str(ref(list, parseInt(code))))}"], ["colored", "(string) {let currentStyles = [], result = \"\"; for (let i = 0; i < string.length; ) {let match = /^\\[(\\/?[a-z]*)\\]/i.exec(string.substring(i)); if (match) {if (match[1][0] === \"/\") {currentStyles.pop(); result += \"\\x1b[0\" + currentStyles.map(c => \";\" + c) + \"m\"} else {let code = styleCodes[match[1]]; currentStyles.push(code); result += \"\\x1b[\" + code + \"m\"}; i += match[0].length} else {result += string[i]; i++}}; return result}"], ["import", "(name) {groupEnv.files[name].run()}"], ["int", "(val, base) {if (isNum(val)) return Math.floor(val); else return parseInt(val, base)}"], ["float", "(val) {if (typeof val === \"boolean\") val = +val; let result = new Number(parseFloat(val)); result.isFloat = true; return result}"], ["round", "(n) {return Math.round(n)}"], ["log", "(n, base) {return f_float(base === undefined ? Math.log(n) : Math.log(n)/Math.log(base))}"], ["sqrt", "(n) {return f_float(Math.sqrt(n))}"], ["sin", "(n) {return f_float(Math.sin(n))}"], ["cos", "(n) {return f_float(Math.cos(n))}"], ["tan", "(n) {return f_float(Math.tan(n))}"], ["asin", "(n) {return f_float(Math.asin(n))}"], ["acos", "(n) {return f_float(Math.acos(n))}"], ["atan", "(n) {return f_float(Math.atan(n))}"], ["atan2", "(n) {return f_float(Math.atan2(n))}"], ["random", "() {return f_float(Math.random())}"], ["randomint", "(a, b) {return Math.floor(Math.random() * (b - a + 1) + a)}"], ["str", "(val) {function f(v, p) {if (typeof v === \"string\") {if (p.length) {return \"'\" + [...v].map(c => {if (c === \"\\\\\" || c === \"'\") return \"\\\\\" + c; else if (c === \"\\t\") return \"\\\\t\"; else if (c === \"\\r\") return \"\\\\r\"; else if (c === \"\\n\") return \"\\\\n\"; else {let n = c.codePointAt(0); if (n < 32 || n === 127) return \"\\\\x\" + n.toString(16).padStart(2, \"0\"); else return c}}).join(\"\") + \"'\"} else {return v}} else if (typeof v === \"number\" || v instanceof Number) {let result = v.toString(); if (v.isFloat && /^-?\\d+$/.test(result)) result += \".0\"; return result} else if (v === true) {return \"True\"} else if (v === false) {return \"False\"} else if (Array.isArray(v)) {if (p.includes(v)) return \"[...]\"; else return \"[\" + v.map(vv => f(vv, p.slice().concat([v]))).join(\", \") + \"]\"} else {return v.toString()}}; return f(val, [])}"], ["len", "(val) {return val.length}"], ["ord", "(c) {return c.codePointAt(0)}"], ["chr", "(n) {return String.fromCodePoint(n)}"], ["lower", "(string) {return string.toLowerCase()}"], ["upper", "(string) {return string.toUpperCase()}"], ["startswith", "(string, check, a, b) {return ref(string, a, b).substring(0, check.length) === check}"], ["endswith", "(string, check, a, b) {let sliced = ref(string, a, b); return sliced.substring(sliced.length - check.length) === check}"], ["replace", "(string, match, insert, count) {let result = \"\"; for (let i = 0; i < string.length; ) {if (string.substring(i, i + match.length) === match) {result += insert; i += match.length} else {result += string[i]; i++}}; return result}"], ["split", "(string, sep, max) {let result = [], startNew = false; if (sep === undefined) string = string.trim(); for (let i = 0; i < string.length; ) {if (sep === undefined) {let match = /^s+/.exec(string.substring(i)); if (match) {i += match[0].length; continue}} else if (string.substring(i, i + sep.length) === sep) {startNew = true; i += sep.length; continue}; if (startNew) {result.push(\"\"); startNew = false}; result[result.length - 1] += string[i]; i++}; return result}"], ["list", "(d) {return [...d]}"], ["append", "(list, d) {list.push(d)}"], ["pop", "(list, i = list.length - 1) {return list.splice(i, 1)[0]}"], ["push", "() {throw \"Unimplemented function\"}"], ["remove", "(list, val) {for (let i = 0; i < list.length; i++) {if (equal(list[i], val)) return list.slice(0, i - 1).concat(list.slice(i + 1))}; throw new Error(\"Value not in list\")}"], ["reverse", "(list) {list.reverse()}"], ["sort", "(list) {list.sort((a, b) => less(a, b) ? -1 : 1)}"]]); setNew(env, "atjs_binfuncs", [["==", ["equal", "(a, b, p = []) {if (isNum(a) && isNum(b)) {return +a === +b} else if (Array.isArray(a) && Array.isArray(b)) {if (p.includes(a) || p.includes(b)) throw new Error(\"Recursion in comparison\"); if (a.length === b.length) {let pp = p.slice().concat([a, b]); for (let i = 0; i < a.length; i++) {if (!equal(a[i], b[i], pp)) return false}; return true} else {return false}} else return a === b}"]], ["!=", ["notEqual", "(a, b) {return !equal(a, b)}"]], ["<=", ["lessEqual", "(a, b) {return equal(a, b) || less(a, b)}"]], [">=", ["greaterEqual", "(a, b) {return !less(a, b)}"]], ["<", ["less", "(a, b, p = []) {if (isNum(a) && isNum(b)) return a < b; else if (typeof a === \"string\" && typeof b === \"string\") return a !== b && [a, b].sort() === a; else if (Array.isArray(a) && Array.isArray(b)) {if (p.includes(a) || p.includes(b)) throw new Error(\"Recursion in comparison\"); let pp = p.slice().concat([a, b]); for (let i = 0; i < a.length || i < b.length; i++) {if (i < a.length) return true; else if (i < b.length) return false; else if (less(a[i], b[i], pp)) return true; else if (less(b[i], a[i], pp)) return false}; return false} else throw new Error(\"Invalid arguments to inequality comparison\")}"]], [">", ["greater", "(a, b) {return !lessEqual(a, b)}"]], ["+", ["add", "(a, b) {if (isNum(a) && isNum(b)) return typeNumOp(a + b, a, b); else return a + b}"]], ["-", ["sub", "(a, b) {return typeNumOp(a - b, a, b)}"]], ["*", ["mul", "(a, b) {if (isNum(a) && isNum(b)) return typeNumOp(a * b, a, b); else if (isNum(a)) return b.repeat(a); else return a.repeat(b)}"]], ["/", ["div", "(a, b) {return f_float(a/b)}"]], ["%", ["mod", "(a, b) {return typeNumOp(a%b, a, b)}"]], ["^", ["exp", "(a, b) {return typeNumOp(a ** b, a, b)}"]]]); setFunc("atjs_isbuiltin", function(env, arg) {env = newEnv(env); setNew(env, "name", arg); setNew(env, "item"); for (let item of get(env, "atjs_builtins")) {set(env, "item", item); if (equal(ref(get(env, "item"), 0), get(env, "name"))) {return true}}; return false}); setFunc("atjs_ref", function(env, ...args) {env = newEnv(env); setNew(env, ["entries", "key"], args); setNew(env, "entry"); for (let item of get(env, "entries")) {set(env, "entry", item); if (equal(ref(get(env, "entry"), 0), get(env, "key"))) {return ref(get(env, "entry"), 1)}}; return false}); setFunc("atjs_hexval", function(env, arg) {env = newEnv(env); setNew(env, "c", arg); setNew(env, "n", f_ord(get(env, "c"))); if (less(get(env, "n"), 65)) {set(env, "n", 48, sub)} else if (less(get(env, "n"), 97)) {set(env, "n", 55, sub)} else {set(env, "n", 87, sub)}; if (bool(and(() => lessEqual(0, get(env, "n")), () => less(get(env, "n"), 16)))) {return get(env, "n")} else {return ""}}); setFunc("atjs_readhex", function(env, ...args) {env = newEnv(env); setNew(env, ["string", "i", "length"], args); setNew(env, "result", 0); setNew(env, "j", 0); setNew(env, "d"); setNew(env, "x"); while (bool(or(() => less(get(env, "j"), get(env, "length")), () => equal(get(env, "length"), -1)))) {set(env, "x", getFunc("atjs_readhex_2")(env)); if (notEqual(get(env, "x"), false)) {return get(env, "x")}}; return get(env, "result")}); setFunc("atjs_readhex_2", function(env) {set(env, "d", ""); if (less(get(env, "i"), f_len(get(env, "string")))) {set(env, "d", getFunc("atjs_hexval")(env, ref(get(env, "string"), get(env, "i"))))}; if (equal(get(env, "d"), "")) {if (equal(get(env, "length"), -1)) {return [get(env, "result"), get(env, "j")]} else {return ""}} else {set(env, "result", add(mul(get(env, "result"), 16), get(env, "d"))); set(env, "i", 1, add); set(env, "j", 1, add)}; return false}); setFunc("atjs_evalescapes", function(env, arg) {env = newEnv(env); setNew(env, "string", arg); setNew(env, "result", ""); setNew(env, "i", 0); setNew(env, "l"); setNew(env, "n"); while (less(get(env, "i"), f_len(get(env, "string")))) {if (equal(ref(get(env, "string"), get(env, "i")), "\\")) {getFunc("atjs_evalescapes_1")(env)} else {set(env, "result", ref(get(env, "string"), get(env, "i")), add)}; set(env, "i", 1, add)}; return get(env, "result")}); setFunc("atjs_evalescapes_1", function(env) {set(env, "i", 1, add); if (equal(ref(get(env, "string"), get(env, "i")), "a")) {set(env, "result", "\u0007", add)} else if (equal(ref(get(env, "string"), get(env, "i")), "b")) {set(env, "result", "\b", add)} else if (equal(ref(get(env, "string"), get(env, "i")), "f")) {set(env, "result", "\f", add)} else if (equal(ref(get(env, "string"), get(env, "i")), "n")) {set(env, "result", "\n", add)} else if (equal(ref(get(env, "string"), get(env, "i")), "r")) {set(env, "result", "\r", add)} else if (equal(ref(get(env, "string"), get(env, "i")), "t")) {set(env, "result", "\t", add)} else if (equal(ref(get(env, "string"), get(env, "i")), "v")) {set(env, "result", "\u000b", add)} else {getFunc("atjs_evalescapes_2")(env)}}); setFunc("atjs_evalescapes_2", function(env) {set(env, "l", false); if (equal(ref(get(env, "string"), get(env, "i")), "x")) {set(env, "l", 2)} else if (equal(ref(get(env, "string"), get(env, "i")), "u")) {set(env, "l", 4)} else if (equal(ref(get(env, "string"), get(env, "i")), "U")) {set(env, "l", 8)} else if (notEqual(getFunc("atjs_hexval")(env, ref(get(env, "string"), get(env, "i"))), "")) {set(env, "l", -1)}; if (greater(get(env, "l"), 0)) {set(env, "i", 1, add)}; set(env, "n", ""); if (bool(get(env, "l"))) {set(env, "n", getFunc("atjs_readhex")(env, get(env, "string"), get(env, "i"), get(env, "l"))); if (equal(get(env, "l"), -1)) {set(env, "l", ref(get(env, "n"), 1)); set(env, "n", ref(get(env, "n"), 0))}}; if (equal(get(env, "n"), "")) {set(env, "result", ref(get(env, "string"), get(env, "i")), add)} else {set(env, "result", f_chr(get(env, "n")), add); set(env, "i", sub(get(env, "l"), 1), add)}}); setFunc("atjs_encstring", function(env, arg) {env = newEnv(env); setNew(env, "string", arg); setNew(env, "result", "\""); setNew(env, "c"); setNew(env, "n"); setNew(env, "p"); setNew(env, "d"); for (let item of get(env, "string")) {set(env, "c", item); getFunc("atjs_encstring_1")(env)}; return add(get(env, "result"), "\"")}); setFunc("atjs_encstring_1", function(env) {if (bool(or(() => equal(get(env, "c"), "\""), () => equal(get(env, "c"), "\\")))) {set(env, "result", add("\\", get(env, "c")), add)} else if (equal(get(env, "c"), "\b")) {set(env, "result", "\\b", add)} else if (equal(get(env, "c"), "\f")) {set(env, "result", "\\f", add)} else if (equal(get(env, "c"), "\n")) {set(env, "result", "\\n", add)} else if (equal(get(env, "c"), "\r")) {set(env, "result", "\\r", add)} else if (equal(get(env, "c"), "\t")) {set(env, "result", "\\t", add)} else {getFunc("atjs_encstring_2")(env)}}); setFunc("atjs_encstring_2", function(env) {set(env, "n", f_ord(get(env, "c"))); if (bool(or(() => and(() => lessEqual(0, get(env, "n")), () => lessEqual(get(env, "n"), 31)), () => and(() => lessEqual(127, get(env, "n")), () => lessEqual(get(env, "n"), 159))))) {set(env, "result", "\\u", add); set(env, "p", 4096); getFunc("atjs_encstring_3")(env)} else {set(env, "result", get(env, "c"), add)}}); setFunc("atjs_encstring_3", function(env) {while (greaterEqual(get(env, "p"), 1)) {set(env, "d", mod(f_int(div(get(env, "n"), get(env, "p"))), 16)); if (less(get(env, "d"), 10)) {set(env, "result", f_str(get(env, "d")), add)} else {set(env, "result", f_chr(add(87, get(env, "d"))), add)}; set(env, "p", 16, div)}}); setFunc("atjs_compile", function(env, ...args) {env = newEnv(env); setNew(env, ["files", "interopvar"], args); setNew(env, "initfiles", []); setNew(env, "extimports", []); setNew(env, "hasdeclare"); setNew(env, "filescode", ""); setNew(env, "file"); setNew(env, "parsed"); setNew(env, "x"); for (let item of get(env, "files")) {set(env, "file", item); set(env, "x", getFunc("atjs_compile_0")(env)); if (notEqual(get(env, "x"), false)) {return get(env, "x")}}; setNew(env, "wrapperparams", ""); setNew(env, "wrapperargs", ""); setNew(env, "initcode", ""); if (greater(f_len(get(env, "extimports")), 0)) {set(env, "wrapperparams", "extImports"); set(env, "initcode", "extImports.forEach(([name, isProp, isFunc, f1, f2]) => {if (isFunc || isProp) {if (groupEnv.funcs[name]) throw new Error(\"Can't import duplicate function \" + JSON.stringify(name)); groupEnv.funcs[name] = {type: \"external\", isProp, func: f1, call(...args) {return this.func(...args)}}} else {if (groupEnv.vars[name]) throw new Error(\"Can't import duplicate variable \" + JSON.stringify(name)); groupEnv.vars[name] = {type: \"external\", isProp, getData: f1, setData: f2, set value(v) {this.setData(v)}, get value() {return this.getData()}}}}); ", add); set(env, "wrapperargs", "["); setNew(env, "ei"); for (let item of get(env, "extimports")) {set(env, "ei", item); getFunc("atjs_compile_2")(env)}; set(env, "wrapperargs", "]", add)}; setNew(env, "result", ""); set(env, "result", add(add(add(add(add(add("(function(", get(env, "wrapperparams")), ") {if (typeof "), get(env, "interopvar")), " === \"undefined\") {"), get(env, "interopvar")), " = {files: {}, funcs: {"), add); setNew(env, "funcinfo"); for (let item of get(env, "atjs_builtins")) {set(env, "funcinfo", item); if (notEqual(ref(get(env, "result"), -1), "{")) {set(env, "result", ", ", add)}; set(env, "result", add(ref(get(env, "funcinfo"), 0), ": 1"), add)}; set(env, "result", add(add(add(add("}, vars: {}}}; let groupEnv = ", get(env, "interopvar")), "; "), get(env, "initcode")), get(env, "filescode")), add); set(env, "result", "let styleCodes = {black: \"30\", red: \"31\", green: \"32\", yellow: \"33\", blue: \"34\", magenta: \"35\", cyan: \"36\", lightgray: \"37\", darkgray: \"90\", lightred: \"91\", lightgreen: \"92\", lightyellow: \"93\", lightblue: \"94\", lightmagenta: \"95\", lightcyan: \"96\", white: \"97\", bold: \"1\", dim: \"2\", italic: \"3\", underline: \"4\", blink: \"5\", reverse: \"7\", hidden: \"8\", bgblack: \"40\", bgred: \"41\", bggreen: \"42\", bgyellow: \"43\", bgblue: \"44\", bgmagenta: \"45\", bgcyan: \"46\", bglightgray: \"47\", bgdarkgray: \"100\", bglightred: \"101\", bglightgreen: \"102\", bglightyellow: \"103\", bglightblue: \"104\", bglightmagenta: \"105\", bglightcyan: \"106\", bgwhite: \"107\"}; ", add); setNew(env, "name"); for (let item of get(env, "initfiles")) {set(env, "name", item); set(env, "result", add(add("groupEnv.files[", getFunc("atjs_encstring")(env, get(env, "name"))), "].run(); "), add)}; for (let item of get(env, "atjs_builtins")) {set(env, "funcinfo", item); set(env, "result", add(add(add(add("function f_", ref(get(env, "funcinfo"), 0)), " "), ref(get(env, "funcinfo"), 1)), "; "), add)}; for (let item of get(env, "atjs_binfuncs")) {set(env, "funcinfo", item); set(env, "result", add(add(add(add("function ", ref(ref(get(env, "funcinfo"), 1), 0)), " "), ref(ref(get(env, "funcinfo"), 1), 1)), "; "), add)}; set(env, "result", "function convertStyles(string) {let resultText = \"%c\", resultStyles = [evalStyles({})], currentStyles = {}; for (let i = 0; i < string.length; ) {if (string.substring(i, i + 2) === \"%\") {resultText += \"%%\"; i++} else {let match = /^\\x1b\\[(\\d*(?:;\\d*|m\\x1b\\[\\d*)*)m/.exec(string.substring(i)); if (match) {match[1].split(/\\D+/).forEach(code => {code = +code; if (code === 0) {currentStyles = {}} else {applyStyle(currentStyles, code)}}); if (/(?:^|[^%])(?:%%)*%c$/.test(resultText)) {resultStyles[resultStyles.length - 1] = evalStyles(currentStyles)} else {resultText += \"%c\"; resultStyles.push(evalStyles(currentStyles))}; i += match[0].length} else {resultText += string[i]; i++}}}; if (/(?:^|[^%])(?:%%)*%c$/.test(resultText)) {resultText = resultText.substring(0, resultText.length - 2); resultStyles.pop()}; if (resultStyles.length) {resultStyles[0] += \"; padding-left: 0.5em\"; resultStyles[resultStyles.length - 1] += \"; padding-right: 0.5em\"}; return [resultText, ...resultStyles]}; ", add); set(env, "result", "function applyStyle(s, c) {let a = Math.floor(c/10), b = c%10; if (a < 3) {let prop = [, \"bold\", \"dim\", \"underline\", \"blink\", \"reverse\", \"hidden\"][b]; s[prop] = a === 0} else {let color = b === 9 ? false : [\"black\", [250, 5, 5], [5, 250, 5], [250, 250, 5], [5, 125, 250], [250, 5, 250], [5, 250, 250], \"white\"][b], dark = a%9 > 1; if (a%2) {s.color = color; s.colorDark = dark} else {s.background = color; s.backgroundDark = dark}}}; ", add); set(env, "result", "function evalStyles(s) {let items = [], fg = evalColor(s.color || \"white\", s.color ? s.colorDark : false, s.dim), bg = evalColor(s.background || \"black\", s.background ? s.backgroundDark : true, false); if (s.reverse) {let x = fg; fg = bg; bg = x}; fg = \"rgb(\" + fg.join(\", \") + \")\"; bg = \"rgb(\" + bg.join(\", \") + \")\"; if (s.hidden) items.push(\"color: transparent\"); else if (s.blink) items.push(\"color: \" + bg, \"text-shadow: 1px 1px 2px \" + fg + \", -1px -1px 2px \" + bg); else items.push(\"color: \" + fg); items.push(\"background: \" + bg); if (s.bold) items.push(\"font-weight: bold\"); if (s.underline) items.push(\"text-decoration: underline\"); return items.join(\"; \")}; ", add); set(env, "result", "function evalColor(c, dark, dim) {if (c === \"white\") {if (dark) {c = [220, 220, 220]} else {c = [250, 250, 250]}} else if (c === \"black\") {if (dark) {c = [5, 5, 5]} else {c = [50, 50, 50]}} else if (dark) {c = c.map(v => v * 0.7)}; if (dim) {let gray = dark ? 40 : 120; c = c.map(v => v * 0.7 + gray * 0.3)}; return c.map(v => Math.round(v))}; ", add); set(env, "result", "function isNum(v) {return typeof v === \"number\" || v instanceof Number || typeof v === \"boolean\"}; ", add); set(env, "result", "function typeNumOp(result, a, b) {return a.isFloat || b.isFloat ? f_float(result) : f_int(result)}; ", add); set(env, "result", "function bool(val) {return isNum(val) ? +val !== 0 : typeof val === \"string\" ? val !== \"\" : Array.isArray(val) ? array.length !== 0 : true}; ", add); set(env, "result", "function or(...funcs) {let result = false; for (let f of funcs) {let fr = f(); if (bool(fr)) return fr; else result = fr}; return result}; ", add); set(env, "result", "function and(...funcs) {let result = true; for (let f of funcs) {let fr = f(); if (!bool(fr)) return fr; else result = fr}; return result}; ", add); set(env, "result", "function ref(d, a, b) {if (a < 0) a += d.length; if (b === undefined) {return d[+a]} else {if (b < 0) b += d.length; return typeof d === \"string\" ? d.substring(a, b) : d.slice(a, b)}}; ", add); set(env, "result", "function listSet(list, index, val, func) {if (index < 0) index += list.length; if (func) list[index] = func(list[index], val); else list[index] = val}; ", add); set(env, "result", "function range(a, b, inclusive) {if (inclusive) b++; let result = []; for (let i = a; i < b; i++) result.push(i); return result}; ", add); set(env, "result", "function newEnv(parent) {return {parent, vars: {}}}; ", add); set(env, "result", "function setNew(env, names, vals) {if (!Array.isArray(names)) {names = [names]; vals = [vals]}; names.forEach((name, i) => {if (env.vars[name]) throw new Error(\"Can't redeclare variable \" + JSON.stringify(name)); env.vars[name] = {type: \"normal\", data: vals[i], get value() {return exportVal(this.data)}, set value(v) {this.data = importVal(v)}}})}; ", add); set(env, "result", "function set(env, name, val, func) {env = getContainingEnv(env, name); let varObj = env.vars[name]; if (func) {setVarByObj(varObj, func(getVarByObj(varObj), val))} else {setVarByObj(varObj, val)}}; ", add); set(env, "result", "function get(env, name) {env = getContainingEnv(env, name, true); if (env.vars[name]) return getVarByObj(env.vars[name]); else if (groupEnv.funcs[name]) {let obj = groupEnv.funcs[name]; return (...args) => obj.call(...args)} else throw new Error(\"Nonexistant variable \" + JSON.stringify(name))}; ", add); set(env, "result", "function getContainingEnv(env, name, failsoft) {if (env.vars[name]) return env; else if (env.parent) return getContainingEnv(env.parent, name, failsoft); else if (failsoft) return env; else throw new Error(\"Nonexistant variable \" + JSON.stringify(name))}; ", add); set(env, "result", "function setVarByObj(obj, val) {if (obj.type === \"external\") {obj.setData(exportVal(val))} else {obj.data = val}}; ", add); set(env, "result", "function getVarByObj(obj) {if (obj.type === \"external\") {return importVal(obj.getData())} else {return obj.data}}; ", add); set(env, "result", "function importVal(val, p = [], pr = []) {if (typeof val === \"number\" || val instanceof Number) return f_float(val); else if (Array.isArray(val)) return convertRecursive(val, p, pr, importVal); else return val}; ", add); set(env, "result", "function exportVal(val, p = [], pr = []) {if (val instanceof Number && val.isFloat) return +val; else if (Array.isArray(val)) return convertRecursive(val, p, pr, exportVal); else return val}; ", add); set(env, "result", "function convertRecursive(val, p, pr, f) {let pi = p.indexOf(val); if (pi === -1) {let result = [], pp = [...p, val], ppr = [...pr, result]; for (let item of val) result.push(f(item, pp, ppr)); return result} else {return pr[pi]}}; ", add); set(env, "result", "function setFunc(name, func) {if (groupEnv.funcs[name]) throw new Error(\"Can't redeclare function \" + JSON.stringify(name)); groupEnv.funcs[name] = {type: \"normal\", func, call(...args) {return exportVal(this.func(groupEnv, ...args.map(v => importVal(v))))}}}; ", add); set(env, "result", "function getFunc(name) {let obj = groupEnv.funcs[name]; if (obj) {if (obj.type === \"external\") {return (env, ...args) => obj.func(...args)} else {return obj.func}} else {throw new Error(\"Nonexistant function \" + JSON.stringify(name))}}; ", add); set(env, "result", add(add("})(", get(env, "wrapperargs")), ");"), add); return [get(env, "result"), false]}); setFunc("atjs_compile_0", function(env) {set(env, "parsed", getFunc("atjs_parse")(env, ref(get(env, "file"), 1), false)); if (bool(ref(get(env, "parsed"), 1))) {return [get(env, "filescode"), ref(get(env, "parsed"), 1)]}; set(env, "filescode", add(add(add(add("groupEnv.files[", getFunc("atjs_encstring")(env, ref(get(env, "file"), 0))), "] = {run(env = groupEnv) {"), getFunc("atjs_compilestatements")(env, ref(get(env, "parsed"), 0))), "}}; "), add); if (bool(and(() => greater(f_len(get(env, "file")), 2), () => ref(get(env, "file"), 2)))) {f_append(get(env, "initfiles"), ref(get(env, "file"), 0))}; return false}); setFunc("atjs_compile_2", function(env) {if (notEqual(ref(get(env, "wrapperargs"), -1), "[")) {set(env, "wrapperargs", ", ", add)}; set(env, "wrapperargs", add(add(add(add(add(add("[", getFunc("atjs_encstring")(env, ref(get(env, "ei"), 3))), ", "), or(() => and(() => ref(get(env, "ei"), 1), () => "true"), () => "false")), ", "), or(() => and(() => ref(get(env, "ei"), 2), () => "true"), () => "false")), ", "), add); if (bool(ref(get(env, "ei"), 2))) {if (bool(ref(get(env, "ei"), 1))) {set(env, "wrapperargs", add(add("(d, ...args) => d", ref(get(env, "ei"), 0)), "(...args)"), add)} else {set(env, "wrapperargs", add(add("(...args) => ", ref(get(env, "ei"), 0)), "(...args)"), add)}} else {if (bool(ref(get(env, "ei"), 1))) {set(env, "wrapperargs", add(add(add(add("(d, v) => {if (v === undefined) return d", ref(get(env, "ei"), 0)), "; else d"), ref(get(env, "ei"), 0)), " = v}"), add)} else {set(env, "wrapperargs", add(add(add(add("() => ", ref(get(env, "ei"), 0)), ", val => "), ref(get(env, "ei"), 0)), " = val"), add)}}; set(env, "wrapperargs", "]", add)}); setFunc("atjs_compilestatements", function(env, arg) {env = newEnv(env); setNew(env, "expr", arg); setNew(env, "result", ""); setNew(env, "statement"); setNew(env, "statementcode"); for (let item of ref(get(env, "expr"), 1)) {set(env, "statement", item); set(env, "statementcode", getFunc("atjs_compilestatement")(env, get(env, "statement"))); getFunc("atjs_compilestatements_2")(env)}; return get(env, "result")}); setFunc("atjs_compilestatements_2", function(env) {if (bool(get(env, "statementcode"))) {if (bool(get(env, "result"))) {set(env, "result", "; ", add)}; set(env, "result", get(env, "statementcode"), add)}}); setFunc("atjs_compilestatement", function(env, arg) {env = newEnv(env); setNew(env, "expr", arg); setNew(env, "type", ref(get(env, "expr"), 0)); setNew(env, "value", ref(get(env, "expr"), 1)); if (equal(get(env, "type"), "statements")) {return add(add("{", getFunc("atjs_compilestatements")(env, get(env, "expr"))), "}")} else if (equal(get(env, "type"), "if")) {setNew(env, "result", add(add(add("if (", getFunc("atjs_compilebool")(env, ref(get(env, "value"), 0))), ") "), getFunc("atjs_compilestatement")(env, ref(get(env, "value"), 1)))); if (greater(f_len(get(env, "value")), 2)) {set(env, "result", add(" else ", getFunc("atjs_compilestatement")(env, ref(get(env, "value"), 2))), add)}; return get(env, "result")} else if (equal(get(env, "type"), "for")) {return add(add(add(add(add(add("for (let item of ", getFunc("atjs_compileexpr")(env, ref(get(env, "value"), 1))), ") {set(env, "), getFunc("atjs_encstring")(env, ref(ref(get(env, "value"), 0), 1))), ", item); "), getFunc("atjs_compilestatements")(env, ref(get(env, "value"), 2))), "}")} else if (equal(get(env, "type"), "while")) {return add(add(add("while (", getFunc("atjs_compilebool")(env, ref(get(env, "value"), 0))), ") "), getFunc("atjs_compilestatement")(env, ref(get(env, "value"), 1)))} else if (equal(get(env, "type"), "function")) {return getFunc("atjs_compilefunction")(env, get(env, "value"))} else if (equal(get(env, "type"), "break")) {return "break"} else {return getFunc("atjs_compilestatement_0")(env)}}); setFunc("atjs_compilestatement_0", function(env) {env = newEnv(env); if (equal(get(env, "type"), "return")) {if (greater(f_len(get(env, "value")), 0)) {return add("return ", getFunc("atjs_compileexpr")(env, ref(get(env, "value"), 0)))} else {return "return"}} else if (equal(get(env, "type"), "declare")) {set(env, "hasdeclare", true); setNew(env, "result", add("setNew(env, ", getFunc("atjs_encstring")(env, ref(ref(get(env, "value"), 0), 1)))); if (greater(f_len(get(env, "value")), 1)) {set(env, "result", add(", ", getFunc("atjs_compileexpr")(env, ref(get(env, "value"), 1))), add)}; return add(get(env, "result"), ")")} else if (equal(get(env, "type"), "call")) {return getFunc("atjs_compilecall")(env)} else if (equal(get(env, "type"), "assign")) {setNew(env, "result", add(add(add("set(env, ", getFunc("atjs_encstring")(env, ref(ref(get(env, "value"), 0), 1))), ", "), getFunc("atjs_compileexpr")(env, ref(get(env, "value"), 2)))); if (notEqual(ref(ref(get(env, "value"), 1), 1), "=")) {set(env, "result", add(", ", ref(getFunc("atjs_ref")(env, get(env, "atjs_binfuncs"), ref(ref(ref(get(env, "value"), 1), 1), 0)), 0)), add)}; return add(get(env, "result"), ")")} else if (equal(get(env, "type"), "listassign")) {setNew(env, "result", add(add(add(add(add("listSet(", getFunc("atjs_compileexpr")(env, ref(get(env, "value"), 0))), ", "), getFunc("atjs_compileexpr")(env, ref(get(env, "value"), 1))), ", "), getFunc("atjs_compileexpr")(env, ref(get(env, "value"), 3)))); if (notEqual(ref(ref(get(env, "value"), 2), 1), "=")) {set(env, "result", add(", ", ref(getFunc("atjs_ref")(env, get(env, "atjs_binfuncs"), ref(ref(ref(get(env, "value"), 2), 1), 0)), 0)), add)}; return add(get(env, "result"), ")")} else if (equal(get(env, "type"), "extimport")) {setNew(env, "name", ""); setNew(env, "isprop", false); setNew(env, "preferfunc", false); setNew(env, "localname"); setNew(env, "i", 0); if (equal(ref(ref(get(env, "value"), 0), 0), "name")) {set(env, "name", ref(ref(get(env, "value"), 0), 1)); set(env, "localname", ref(ref(get(env, "value"), 0), 1)); set(env, "i", 1, add)}; getFunc("atjs_compilestatement_2")(env); if (bool(and(() => less(get(env, "i"), f_len(get(env, "value"))), () => equal(ref(ref(get(env, "value"), get(env, "i")), 0), "(")))) {set(env, "preferfunc", true); set(env, "i", 1, add)}; if (less(get(env, "i"), f_len(get(env, "value")))) {set(env, "localname", ref(ref(get(env, "value"), get(env, "i")), 1))}; f_append(get(env, "extimports"), [get(env, "name"), get(env, "isprop"), get(env, "preferfunc"), get(env, "localname")]); return ""} else {return "INVALID STATEMENT TYPE"}}); setFunc("atjs_compilestatement_2", function(env) {env = newEnv(env); if (bool(and(() => less(get(env, "i"), f_len(get(env, "value"))), () => equal(ref(ref(get(env, "value"), get(env, "i")), 0), "propref")))) {if (!bool(get(env, "name"))) {set(env, "isprop", true)}; setNew(env, "propname"); for (let item of ref(ref(get(env, "value"), get(env, "i")), 1)) {set(env, "propname", item); set(env, "name", add(".", ref(get(env, "propname"), 1)), add); set(env, "localname", ref(get(env, "propname"), 1))}; set(env, "i", 1, add)}}); setFunc("atjs_compilefunction", function(env, arg) {env = newEnv(env); setNew(env, "value", arg); setNew(env, "name", ref(ref(get(env, "value"), 0), 1)); setNew(env, "params", ref(ref(get(env, "value"), 1), 1)); setNew(env, "body", ref(get(env, "value"), 2)); setNew(env, "hasdeclare", false); setNew(env, "bodycode", getFunc("atjs_compilestatements")(env, ref(get(env, "value"), 2))); setNew(env, "bodystart", ""); setNew(env, "paramscode", "env"); if (bool(or(() => get(env, "hasdeclare"), () => f_len(get(env, "params"))))) {set(env, "bodystart", "env = newEnv(env); ")}; if (greater(f_len(get(env, "params")), 1)) {set(env, "paramscode", ", ...args", add); set(env, "bodystart", "setNew(env, [", add); setNew(env, "param"); getFunc("atjs_compilefunction_2")(env); set(env, "bodystart", "], args); ", add)} else if (bool(f_len(get(env, "params")))) {set(env, "paramscode", ", arg", add); set(env, "bodystart", add(add("setNew(env, ", getFunc("atjs_encstring")(env, ref(ref(get(env, "params"), 0), 1))), ", arg); "), add)}; return add(add(add(add(add(add(add("setFunc(", getFunc("atjs_encstring")(env, get(env, "name"))), ", function("), get(env, "paramscode")), ") {"), get(env, "bodystart")), get(env, "bodycode")), "})")}); setFunc("atjs_compilefunction_2", function(env) {for (let item of get(env, "params")) {set(env, "param", item); if (notEqual(ref(get(env, "bodystart"), -1), "[")) {set(env, "bodystart", ", ", add)}; set(env, "bodystart", getFunc("atjs_encstring")(env, ref(get(env, "param"), 1)), add)}}); setFunc("atjs_compileexpr", function(env, arg) {env = newEnv(env); setNew(env, "expr", arg); setNew(env, "type", ref(get(env, "expr"), 0)); setNew(env, "value", ref(get(env, "expr"), 1)); if (bool(or(() => equal(get(env, "type"), "or"), () => equal(get(env, "type"), "and")))) {setNew(env, "result", add(get(env, "type"), "(")); setNew(env, "arg"); getFunc("atjs_compileexpr_0")(env); return add(get(env, "result"), ")")} else if (equal(get(env, "type"), "binop")) {setNew(env, "result", getFunc("atjs_compileexpr")(env, ref(get(env, "value"), 0))); setNew(env, "i", 1); while (less(get(env, "i"), f_len(get(env, "value")))) {set(env, "result", add(add(add(add(add(ref(getFunc("atjs_ref")(env, get(env, "atjs_binfuncs"), ref(ref(get(env, "value"), get(env, "i")), 1)), 0), "("), get(env, "result")), ", "), getFunc("atjs_compileexpr")(env, ref(get(env, "value"), add(get(env, "i"), 1)))), ")")); set(env, "i", 2, add)}; return get(env, "result")} else if (equal(get(env, "type"), "range")) {return add(add(add(add(add("range(", getFunc("atjs_compileexpr")(env, ref(get(env, "value"), 0))), ", "), getFunc("atjs_compileexpr")(env, ref(get(env, "value"), 2))), or(() => and(() => equal(ref(ref(get(env, "value"), 1), 1), "to"), () => ", true"), () => "")), ")")} else if (equal(get(env, "type"), "listref")) {setNew(env, "result", ""); setNew(env, "param"); for (let item of get(env, "value")) {set(env, "param", item); getFunc("atjs_compileexpr_2")(env)}; return get(env, "result")} else if (equal(get(env, "type"), "number")) {return get(env, "value")} else if (equal(get(env, "type"), "string")) {return getFunc("atjs_encstring")(env, getFunc("atjs_evalescapes")(env, ref(get(env, "value"), 1, -1)))} else if (bool(or(() => equal(get(env, "type"), "true"), () => equal(get(env, "type"), "false")))) {return get(env, "type")} else if (equal(get(env, "type"), "list")) {setNew(env, "result", "["); setNew(env, "item"); getFunc("atjs_compileexpr_3")(env); return add(get(env, "result"), "]")} else if (equal(get(env, "type"), "neg")) {return add(add("sub(0, ", getFunc("atjs_compileexpr")(env, ref(get(env, "value"), 0))), ")")} else if (equal(get(env, "type"), "abs")) {return add(add("abs(", getFunc("atjs_compileexpr")(env, ref(get(env, "value"), 0))), ")")} else if (equal(get(env, "type"), "not")) {return add("!", getFunc("atjs_compilebool")(env, ref(get(env, "value"), 0)))} else if (equal(get(env, "type"), "name")) {return add(add("get(env, ", getFunc("atjs_encstring")(env, get(env, "value"))), ")")} else if (equal(get(env, "type"), "call")) {return getFunc("atjs_compilecall")(env)} else {return "INVALID EXPRESSION TYPE"}}); setFunc("atjs_compileexpr_0", function(env) {for (let item of get(env, "value")) {set(env, "arg", item); if (notEqual(ref(get(env, "result"), -1), "(")) {set(env, "result", ", ", add)}; set(env, "result", add("() => ", getFunc("atjs_compileexpr")(env, get(env, "arg"))), add)}}); setFunc("atjs_compileexpr_2", function(env) {if (bool(get(env, "result"))) {set(env, "result", add(add("ref(", get(env, "result")), ", ")); if (equal(ref(get(env, "param"), 0), "slice")) {getFunc("atjs_compileexpr_2_2")(env)} else {set(env, "result", getFunc("atjs_compileexpr")(env, get(env, "param")), add)}; set(env, "result", ")", add)} else {set(env, "result", getFunc("atjs_compileexpr")(env, get(env, "param")))}}); setFunc("atjs_compileexpr_2_2", function(env) {if (equal(ref(ref(ref(get(env, "param"), 1), 0), 0), "empty")) {set(env, "result", "0", add)} else {set(env, "result", getFunc("atjs_compileexpr")(env, ref(ref(get(env, "param"), 1), 0)), add)}; set(env, "result", ", ", add); if (equal(f_len(ref(get(env, "param"), 1)), 1)) {set(env, "result", "Infinity", add)} else {set(env, "result", getFunc("atjs_compileexpr")(env, ref(ref(get(env, "param"), 1), 1)), add)}}); setFunc("atjs_compileexpr_3", function(env) {for (let item of get(env, "value")) {set(env, "item", item); if (notEqual(ref(get(env, "result"), -1), "[")) {set(env, "result", ", ", add)}; set(env, "result", getFunc("atjs_compileexpr")(env, get(env, "item")), add)}}); setFunc("atjs_compilecall", function(env) {env = newEnv(env); setNew(env, "result"); if (bool(getFunc("atjs_isbuiltin")(env, ref(ref(get(env, "value"), 0), 1)))) {set(env, "result", add(add("f_", ref(ref(get(env, "value"), 0), 1)), "("))} else {set(env, "result", add(add("getFunc(", getFunc("atjs_encstring")(env, ref(ref(get(env, "value"), 0), 1))), ")(env"))}; setNew(env, "arg"); for (let item of ref(ref(get(env, "value"), 1), 1)) {set(env, "arg", item); if (notEqual(ref(get(env, "result"), -1), "(")) {set(env, "result", ", ", add)}; set(env, "result", getFunc("atjs_compileexpr")(env, get(env, "arg")), add)}; return add(get(env, "result"), ")")}); setFunc("atjs_compilebool", function(env, arg) {env = newEnv(env); setNew(env, "expr", arg); setNew(env, "type", ref(get(env, "expr"), 0)); setNew(env, "value", ref(get(env, "expr"), 1)); setNew(env, "result", getFunc("atjs_compileexpr")(env, get(env, "expr"))); if (!bool(or(() => equal(get(env, "type"), "not"), () => equal(get(env, "type"), "string"), () => equal(get(env, "type"), "number"), () => and(() => equal(get(env, "type"), "binop"), () => equal(ref(ref(get(env, "value"), 1), 0), "compareop"))))) {set(env, "result", add(add("bool(", get(env, "result")), ")"))}; return get(env, "result")})}}; let styleCodes = {black: "30", red: "31", green: "32", yellow: "33", blue: "34", magenta: "35", cyan: "36", lightgray: "37", darkgray: "90", lightred: "91", lightgreen: "92", lightyellow: "93", lightblue: "94", lightmagenta: "95", lightcyan: "96", white: "97", bold: "1", dim: "2", italic: "3", underline: "4", blink: "5", reverse: "7", hidden: "8", bgblack: "40", bgred: "41", bggreen: "42", bgyellow: "43", bgblue: "44", bgmagenta: "45", bgcyan: "46", bglightgray: "47", bgdarkgray: "100", bglightred: "101", bglightgreen: "102", bglightyellow: "103", bglightblue: "104", bglightmagenta: "105", bglightcyan: "106", bgwhite: "107"}; groupEnv.files["atjs.tal"].run(); function f_print (...args) {console.log(...convertStyles(args.map(d => f_str(d)).join(" ")))}; function f_printf (string, list) {f_print(f_format(string, list))}; function f_printc (string) {f_print(f_colored(string))}; function f_getstr (message) {return prompt(message === undefined ? undefined : f_str(message))}; function f_format (string, list) {return string.replace(/%(%|-?\d+)/, (m, code) => code == "%" ? "%" : f_str(ref(list, parseInt(code))))}; function f_colored (string) {let currentStyles = [], result = ""; for (let i = 0; i < string.length; ) {let match = /^\[(\/?[a-z]*)\]/i.exec(string.substring(i)); if (match) {if (match[1][0] === "/") {currentStyles.pop(); result += "\x1b[0" + currentStyles.map(c => ";" + c) + "m"} else {let code = styleCodes[match[1]]; currentStyles.push(code); result += "\x1b[" + code + "m"}; i += match[0].length} else {result += string[i]; i++}}; return result}; function f_import (name) {groupEnv.files[name].run()}; function f_int (val, base) {if (isNum(val)) return Math.floor(val); else return parseInt(val, base)}; function f_float (val) {if (typeof val === "boolean") val = +val; let result = new Number(parseFloat(val)); result.isFloat = true; return result}; function f_round (n) {return Math.round(n)}; function f_log (n, base) {return f_float(base === undefined ? Math.log(n) : Math.log(n)/Math.log(base))}; function f_sqrt (n) {return f_float(Math.sqrt(n))}; function f_sin (n) {return f_float(Math.sin(n))}; function f_cos (n) {return f_float(Math.cos(n))}; function f_tan (n) {return f_float(Math.tan(n))}; function f_asin (n) {return f_float(Math.asin(n))}; function f_acos (n) {return f_float(Math.acos(n))}; function f_atan (n) {return f_float(Math.atan(n))}; function f_atan2 (n) {return f_float(Math.atan2(n))}; function f_random () {return f_float(Math.random())}; function f_randomint (a, b) {return Math.floor(Math.random() * (b - a + 1) + a)}; function f_str (val) {function f(v, p) {if (typeof v === "string") {if (p.length) {return "'" + [...v].map(c => {if (c === "\\" || c === "'") return "\\" + c; else if (c === "\t") return "\\t"; else if (c === "\r") return "\\r"; else if (c === "\n") return "\\n"; else {let n = c.codePointAt(0); if (n < 32 || n === 127) return "\\x" + n.toString(16).padStart(2, "0"); else return c}}).join("") + "'"} else {return v}} else if (typeof v === "number" || v instanceof Number) {let result = v.toString(); if (v.isFloat && /^-?\d+$/.test(result)) result += ".0"; return result} else if (v === true) {return "True"} else if (v === false) {return "False"} else if (Array.isArray(v)) {if (p.includes(v)) return "[...]"; else return "[" + v.map(vv => f(vv, p.slice().concat([v]))).join(", ") + "]"} else {return v.toString()}}; return f(val, [])}; function f_len (val) {return val.length}; function f_ord (c) {return c.codePointAt(0)}; function f_chr (n) {return String.fromCodePoint(n)}; function f_lower (string) {return string.toLowerCase()}; function f_upper (string) {return string.toUpperCase()}; function f_startswith (string, check, a, b) {return ref(string, a, b).substring(0, check.length) === check}; function f_endswith (string, check, a, b) {let sliced = ref(string, a, b); return sliced.substring(sliced.length - check.length) === check}; function f_replace (string, match, insert, count) {let result = ""; for (let i = 0; i < string.length; ) {if (string.substring(i, i + match.length) === match) {result += insert; i += match.length} else {result += string[i]; i++}}; return result}; function f_split (string, sep, max) {let result = [], startNew = false; if (sep === undefined) string = string.trim(); for (let i = 0; i < string.length; ) {if (sep === undefined) {let match = /^\s+/.exec(string.substring(i)); if (match) {i += match[0].length; continue}} else if (string.substring(i, i + sep.length) === sep) {startNew = true; i += sep.length; continue}; if (startNew) {result.push(""); startNew = false}; result[result.length - 1] += string[i]; i++}; return result}; function f_list (d) {return [...d]}; function f_append (list, d) {list.push(d)}; function f_pop (list, i = list.length - 1) {return list.splice(i, 1)[0]}; function f_push () {throw "Unimplemented function"}; function f_remove (list, val) {for (let i = 0; i < list.length; i++) {if (equal(list[i], val)) return list.slice(0, i - 1).concat(list.slice(i + 1))}; throw new Error("Value not in list")}; function f_reverse (list) {list.reverse()}; function f_sort (list) {list.sort((a, b) => less(a, b) ? -1 : 1)}; function equal (a, b, p = []) {if (isNum(a) && isNum(b)) {return +a === +b} else if (Array.isArray(a) && Array.isArray(b)) {if (p.includes(a) || p.includes(b)) throw new Error("Recursion in comparison"); if (a.length === b.length) {let pp = p.slice().concat([a, b]); for (let i = 0; i < a.length; i++) {if (!equal(a[i], b[i], pp)) return false}; return true} else {return false}} else return a === b}; function notEqual (a, b) {return !equal(a, b)}; function lessEqual (a, b) {return equal(a, b) || less(a, b)}; function greaterEqual (a, b) {return !less(a, b)}; function less (a, b, p = []) {if (isNum(a) && isNum(b)) return a < b; else if (typeof a === "string" && typeof b === "string") return a !== b && [a, b].sort() === a; else if (Array.isArray(a) && Array.isArray(b)) {if (p.includes(a) || p.includes(b)) throw new Error("Recursion in comparison"); let pp = p.slice().concat([a, b]); for (let i = 0; i < a.length || i < b.length; i++) {if (i < a.length) return true; else if (i < b.length) return false; else if (less(a[i], b[i], pp)) return true; else if (less(b[i], a[i], pp)) return false}; return false} else throw new Error("Invalid arguments to inequality comparison")}; function greater (a, b) {return !lessEqual(a, b)}; function add (a, b) {if (isNum(a) && isNum(b)) return typeNumOp(a + b, a, b); else return a + b}; function sub (a, b) {return typeNumOp(a - b, a, b)}; function mul (a, b) {if (isNum(a) && isNum(b)) return typeNumOp(a * b, a, b); else if (isNum(a)) return b.repeat(a); else return a.repeat(b)}; function div (a, b) {return f_float(a/b)}; function mod (a, b) {return typeNumOp(a%b, a, b)}; function exp (a, b) {return typeNumOp(a ** b, a, b)}; function convertStyles(string) {let resultText = "%c", resultStyles = [evalStyles({})], currentStyles = {}; for (let i = 0; i < string.length; ) {if (string.substring(i, i + 2) === "%") {resultText += "%%"; i++} else {let match = /^\x1b\[(\d*(?:;\d*|m\x1b\[\d*)*)m/.exec(string.substring(i)); if (match) {match[1].split(/\D+/).forEach(code => {code = +code; if (code === 0) {currentStyles = {}} else {applyStyle(currentStyles, code)}}); if (/(?:^|[^%])(?:%%)*%c$/.test(resultText)) {resultStyles[resultStyles.length - 1] = evalStyles(currentStyles)} else {resultText += "%c"; resultStyles.push(evalStyles(currentStyles))}; i += match[0].length} else {resultText += string[i]; i++}}}; if (/(?:^|[^%])(?:%%)*%c$/.test(resultText)) {resultText = resultText.substring(0, resultText.length - 2); resultStyles.pop()}; if (resultStyles.length) {resultStyles[0] += "; padding-left: 0.5em"; resultStyles[resultStyles.length - 1] += "; padding-right: 0.5em"}; return [resultText, ...resultStyles]}; function applyStyle(s, c) {let a = Math.floor(c/10), b = c%10; if (a < 3) {let prop = [, "bold", "dim", "underline", "blink", "reverse", "hidden"][b]; s[prop] = a === 0} else {let color = b === 9 ? false : ["black", [250, 5, 5], [5, 250, 5], [250, 250, 5], [5, 125, 250], [250, 5, 250], [5, 250, 250], "white"][b], dark = a%9 > 1; if (a%2) {s.color = color; s.colorDark = dark} else {s.background = color; s.backgroundDark = dark}}}; function evalStyles(s) {let items = [], fg = evalColor(s.color || "white", s.color ? s.colorDark : false, s.dim), bg = evalColor(s.background || "black", s.background ? s.backgroundDark : true, false); if (s.reverse) {let x = fg; fg = bg; bg = x}; fg = "rgb(" + fg.join(", ") + ")"; bg = "rgb(" + bg.join(", ") + ")"; if (s.hidden) items.push("color: transparent"); else if (s.blink) items.push("color: " + bg, "text-shadow: 1px 1px 2px " + fg + ", -1px -1px 2px " + bg); else items.push("color: " + fg); items.push("background: " + bg); if (s.bold) items.push("font-weight: bold"); if (s.underline) items.push("text-decoration: underline"); return items.join("; ")}; function evalColor(c, dark, dim) {if (c === "white") {if (dark) {c = [220, 220, 220]} else {c = [250, 250, 250]}} else if (c === "black") {if (dark) {c = [5, 5, 5]} else {c = [50, 50, 50]}} else if (dark) {c = c.map(v => v * 0.7)}; if (dim) {let gray = dark ? 40 : 120; c = c.map(v => v * 0.7 + gray * 0.3)}; return c.map(v => Math.round(v))}; function isNum(v) {return typeof v === "number" || v instanceof Number || typeof v === "boolean"}; function typeNumOp(result, a, b) {return a.isFloat || b.isFloat ? f_float(result) : f_int(result)}; function bool(val) {return isNum(val) ? +val !== 0 : typeof val === "string" ? val !== "" : Array.isArray(val) ? array.length !== 0 : true}; function or(...funcs) {let result = false; for (let f of funcs) {let fr = f(); if (bool(fr)) return fr; else result = fr}; return result}; function and(...funcs) {let result = true; for (let f of funcs) {let fr = f(); if (!bool(fr)) return fr; else result = fr}; return result}; function ref(d, a, b) {if (a < 0) a += d.length; if (b === undefined) {return d[+a]} else {if (b < 0) b += d.length; return typeof d === "string" ? d.substring(a, b) : d.slice(a, b)}}; function listSet(list, index, val, func) {if (index < 0) index += list.length; if (func) list[index] = func(list[index], val); else list[index] = val}; function range(a, b, inclusive) {if (inclusive) b++; let result = []; for (let i = a; i < b; i++) result.push(i); return result}; function newEnv(parent) {return {parent, vars: {}}}; function setNew(env, names, vals) {if (!Array.isArray(names)) {names = [names]; vals = [vals]}; names.forEach((name, i) => {if (env.vars[name]) throw new Error("Can't redeclare variable " + JSON.stringify(name)); env.vars[name] = {type: "normal", data: vals[i], get value() {return exportVal(this.data)}, set value(v) {this.data = importVal(v)}}})}; function set(env, name, val, func) {env = getContainingEnv(env, name); let varObj = env.vars[name]; if (func) {setVarByObj(varObj, func(getVarByObj(varObj), val))} else {setVarByObj(varObj, val)}}; function get(env, name) {env = getContainingEnv(env, name, true); if (env.vars[name]) return getVarByObj(env.vars[name]); else if (groupEnv.funcs[name]) {let obj = groupEnv.funcs[name]; return (...args) => obj.call(...args)} else throw new Error("Nonexistant variable " + JSON.stringify(name))}; function getContainingEnv(env, name, failsoft) {if (env.vars[name]) return env; else if (env.parent) return getContainingEnv(env.parent, name, failsoft); else if (failsoft) return env; else throw new Error("Nonexistant variable " + JSON.stringify(name))}; function setVarByObj(obj, val) {if (obj.type === "external") {obj.setData(exportVal(val))} else {obj.data = val}}; function getVarByObj(obj) {if (obj.type === "external") {return importVal(obj.getData())} else {return obj.data}}; function importVal(val, p = [], pr = []) {if (typeof val === "number" || val instanceof Number) return f_float(val); else if (Array.isArray(val)) return convertRecursive(val, p, pr, importVal); else return val}; function exportVal(val, p = [], pr = []) {if (val instanceof Number && val.isFloat) return +val; else if (Array.isArray(val)) return convertRecursive(val, p, pr, exportVal); else return val}; function convertRecursive(val, p, pr, f) {let pi = p.indexOf(val); if (pi === -1) {let result = [], pp = [...p, val], ppr = [...pr, result]; for (let item of val) result.push(f(item, pp, ppr)); return result} else {return pr[pi]}}; function setFunc(name, func) {if (groupEnv.funcs[name]) throw new Error("Can't redeclare function " + JSON.stringify(name)); groupEnv.funcs[name] = {type: "normal", func, call(...args) {return exportVal(this.func(groupEnv, ...args.map(v => importVal(v))))}}}; function getFunc(name) {let obj = groupEnv.funcs[name]; if (obj) {if (obj.type === "external") {return (env, ...args) => obj.func(...args)} else {return obj.func}} else {throw new Error("Nonexistant function " + JSON.stringify(name))}}; })();
